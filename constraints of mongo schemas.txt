| Constraint  | Syntax / Option                | Description                                                     |
| ----------- | ------------------------------ | --------------------------------------------------------------- |
| `required`  | `required: true`               | Field **must be provided** (non-null equivalent).               |
| `unique`    | `unique: true`                 | Creates a **unique index** — no duplicates allowed.             |
| `default`   | `default: value`               | Provides a **default value** if not specified.                  |
| `type`      | `type: String/Number/...`      | Defines the **data type** of the field.                         |
| `enum`      | `enum: [val1, val2]`           | Restricts the value to a **specific set of allowed values**.    |
| `min`       | `min: number`                  | For numbers: **minimum allowed value**.                         |
| `max`       | `max: number`                  | For numbers: **maximum allowed value**.                         |
| `minLength` | `minLength: number`            | For strings/arrays: **minimum number of characters/items**.     |
| `maxLength` | `maxLength: number`            | For strings/arrays: **maximum number of characters/items**.     |
| `match`     | `match: regex`                 | Validates string against a **regular expression**.              |
| `validate`  | `validate: function or object` | Custom validator function — full control over validation logic. |
| `immutable` | `immutable: true`              | Field **cannot be changed** after creation.                     |
| `select`    | `select: false`                | Field is **excluded from query results** by default.            |
| `alias`     | `alias: 'nickname'`            | Alternate field name used when reading the value.               |
| `index`     | `index: true`                  | Adds a **MongoDB index** on the field for faster lookups.       |
| `sparse`    | `sparse: true`                 | Used with `unique` to allow **multiple nulls**.                 |
| `expires`   | `expires: '60s'`               | TTL: Sets an **expiration time** (used with `Date` fields).     |


Tag	Description
autoescape	Specifies if autoescape mode is on or off
block	Specifies a block section
comment	Specifies a comment section
csrf_token	Protects forms from Cross Site Request Forgeries
cycle	Specifies content to use in each cycle of a loop
debug	Specifies debugging information
extends	Specifies a parent template
filter	Filters content before returning it
firstof	Returns the first not empty variable
for	Specifies a for loop
if	Specifies a if statement
ifchanged	Used in for loops. Outputs a block only if a value has changed since the last iteration
include	Specifies included content/template
load	Loads template tags from another library
lorem	Outputs random text
now	Outputs the current date/time
regroup	Sorts an object by a group
resetcycle	Used in cycles. Resets the cycle
spaceless	Removes whitespace between HTML tags
templatetag	Outputs a specified template tag
url	Returns the absolute URL part of a URL
verbatim	Specifies contents that should not be rendered by the template engine
widthratio	Calculates a width value based on the ratio between a given value and a max value
with	Specifies a variable to use in the block



from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from .models import Task
from .serializers import TaskSerializer

@api_view(['GET'])
def get_all_items(request):
    tasks = Task.objects.all()
    serializer = TaskSerializer(tasks, many=True)
    return Response({'tasks': serializer.data}, status=200)


@api_view(['POST'])
def create_item(request):
    serializer = TaskSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response({'task': serializer.data}, status=201)
    return Response(serializer.errors, status=400)


@api_view(['GET'])
def get_single_item(request, pk):
    try:
        task = Task.objects.get(id=pk)
        serializer = TaskSerializer(task)
        return Response({'task': serializer.data}, status=200)
    except Task.DoesNotExist:
        return Response({'msg': f'No task with id: {pk}'}, status=404)


@api_view(['PUT', 'PATCH'])
def update_item(request, pk):
    try:
        task = Task.objects.get(id=pk)
    except Task.DoesNotExist:
        return Response({'msg': f'Resource of id {pk} not available'}, status=404)

    serializer = TaskSerializer(task, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response({'task': serializer.data}, status=200)
    return Response(serializer.errors, status=400)


@api_view(['DELETE'])
def delete_item(request, pk):
    try:
        task = Task.objects.get(id=pk)
        task.delete()
        return Response({'msg': f'Task with id {pk} deleted'}, status=200)
    except Task.DoesNotExist:
        return Response({'msg': f'Resource of id {pk} not available'}, status=404)


| SQLite Type        | Django Field                                               | Notes                              |
| ------------------ | ---------------------------------------------------------- | ---------------------------------- |
| `TEXT`             | `models.CharField(max_length=...)` or `models.TextField()` | `CharField` needs `max_length`     |
| `INTEGER`          | `models.IntegerField()`                                    | For whole numbers                  |
| `REAL`             | `models.FloatField()`                                      | For decimals                       |
| `NUMERIC`          | `models.DecimalField(...)` or `models.BooleanField()`      | For precision decimals or booleans |
| `BLOB`             | `models.BinaryField()`                                     | For raw binary data                |
| `DATE`, `DATETIME` | `models.DateField()`, `models.DateTimeField()`             | Auto timestamps possible           |



from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from django.forms.models import model_to_dict
from django.core.exceptions import ValidationError
from .models import Task
import json

@api_view(['GET'])
def get_all_items(request):
    tasks = Task.objects.all()
    # Convert QuerySet to list of dictionaries
    task_list = [model_to_dict(task) for task in tasks]
    return Response({'tasks': task_list}, status=200)

@api_view(['POST'])
def create_item(request):
    try:
        # Manual validation and creation
        title = request.data.get('title')
        description = request.data.get('description', '')
        completed = request.data.get('completed', False)
        
        # Basic validation
        if not title:
            return Response({'error': 'Title is required'}, status=400)
        
        # Create the task
        task = Task.objects.create(
            title=title,
            description=description,
            completed=completed
        )
        
        return Response({'task': model_to_dict(task)}, status=201)
    
    except Exception as e:
        return Response({'error': str(e)}, status=400)

@api_view(['GET'])
def get_single_item(request, pk):
    try:
        task = Task.objects.get(id=pk)
        return Response({'task': model_to_dict(task)}, status=200)
    except Task.DoesNotExist:
        return Response({'msg': f'No task with id: {pk}'}, status=404)

@api_view(['PUT', 'PATCH'])
def update_item(request, pk):
    try:
        task = Task.objects.get(id=pk)
    except Task.DoesNotExist:
        return Response({'msg': f'Resource of id {pk} not available'}, status=404)
    
    try:
        # Update fields if provided
        if 'title' in request.data:
            task.title = request.data['title']
        if 'description' in request.data:
            task.description = request.data['description']
        if 'completed' in request.data:
            task.completed = request.data['completed']
        
        # Validate and save
        task.full_clean()  # This runs model validation
        task.save()
        
        return Response({'task': model_to_dict(task)}, status=200)
    
    except ValidationError as e:
        return Response({'errors': e.message_dict}, status=400)
    except Exception as e:
        return Response({'error': str(e)}, status=400)

@api_view(['DELETE'])
def delete_item(request, pk):
    try:
        task = Task.objects.get(id=pk)
        task.delete()
        return Response({'msg': f'Task with id {pk} deleted'}, status=200)
    except Task.DoesNotExist:
        return Response({'msg': f'Resource of id {pk} not available'}, status=404)




class TaskAPIView(APIView):
    """
    Handle GET (list all) and POST (create) for tasks
    """
    
    def get(self, request):
        tasks = Task.objects.all()
        task_list = [model_to_dict(task) for task in tasks]
        return Response({'tasks': task_list}, status=200)
    
    def post(self, request):
        try:
            title = request.data.get('title')
            description = request.data.get('description', '')
            completed = request.data.get('completed', False)
            
            if not title:
                return Response({'error': 'Title is required'}, status=400)
            
            task = Task.objects.create(
                title=title,
                description=description,
                completed=completed
            )
            
            return Response({'task': model_to_dict(task)}, status=201)
        
        except Exception as e:
            return Response({'error': str(e)}, status=400)

class TaskDetailAPIView(APIView):
    """
    Handle GET (single), PUT/PATCH (update), and DELETE for a specific task
    """
    
    def get_object(self, pk):
        try:
            return Task.objects.get(pk=pk)
        except Task.DoesNotExist:
            return None
    
    def get(self, request, pk):
        task = self.get_object(pk)
        if not task:
            return Response({'msg': f'No task with id: {pk}'}, status=404)
        
        return Response({'task': model_to_dict(task)}, status=200)
    
    def put(self, request, pk):
        return self._update(request, pk)
    
    def patch(self, request, pk):
        return self._update(request, pk)
    
    def _update(self, request, pk):
        task = self.get_object(pk)
        if not task:
            return Response({'msg': f'Resource of id {pk} not available'}, status=404)
        
        try:
            if 'title' in request.data:
                task.title = request.data['title']
            if 'description' in request.data:
                task.description = request.data['description']
            if 'completed' in request.data:
                task.completed = request.data['completed']
            
            task.full_clean()
            task.save()
            
            return Response({'task': model_to_dict(task)}, status=200)
        
        except ValidationError as e:
            return Response({'errors': e.message_dict}, status=400)
        except Exception as e:
            return Response({'error': str(e)}, status=400)
    
    def delete(self, request, pk):
        task = self.get_object(pk)
        if not task:
            return Response({'msg': f'Resource of id {pk} not available'}, status=404)
        
        task.delete()
        return Response({'msg': f'Task with id {pk} deleted'}, status=200)